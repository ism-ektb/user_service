Задания проекта


Общее описание задачи
Организация мероприятий. Сервис, который полезен и организаторам, т.к. в нем можно создавать задачи, которые можно распределить между организаторской командой, и участникам, т.к. можно зарегистрироваться на какое-либо мероприятие.



Задачи

Спринт 1: 14 ноября - 20 ноября

Требования к задачам 1-5: обязательно миграции и docker (два контейнера - само приложение и база данных, файл docker-compose). Обязательно юнит и интеграционные тесты.


Задача 1

Написать микросервис user_service. Эндпоинты:

POST /users - создание пользователя

PATCH /users - обновление пользователя (userId (кто делает запрос) берем из header и проверяем верность введенного пароля, нельзя обновить email)

GET /users/{id}  - вернуть пользователя по id (без пароля, НО если запрашивает сам себя (проверяем по header), то с паролем)

GET /users?page={page}&size={size} - получение пользователей с пагинацией (вернуть без паролей)

DELETE /users - удаление пользователя по id (userId (кто делает запрос) берем из header и проверяем верность введенного пароля)

Модель User включает следующие поля: name, email, password, aboutMe


Задача 2

Написать микросервис event_service. Эндпоинты:POST /events - создание события

PATCH /events/{id} - обновление события по id (по header убеждаемся, что запрос делает создатель, нельзя обновить createdDateTime и ownerId)

GET /events/{id} - получение события по id (если запрашивает создатель, то вернуть с полем createdDateTime, иначе без него)

GET /events?page={page}&size={size}&ownerId={ownerId} - получение событий с пагинацией и необязательным фильтров по владельцу

DELETE /events/{id} - удаление события по id (удалить может только создатель, проверяем по header)

Модель Event включает следующие поля: name, description, createdDateTime, startDateTime, endDateTime, location, ownerId


Задача 3

Написать микросервис task_service. Эндпоинты:

POST /tasks - создание задачи

PATCH /tasks/{id} - обновление задачи по id (проверка по header - обновлять могут только автор или исполнитель задачи, нельзя обновить createdDateTime и authorId)

GET /tasks/{id} - получение задачи по id

GET /tasks?page={page}&size={size}&eventId={eventId}&assignTo={assigneeId}&authorId={authorId} - получение задач с пагинацией и необязательными фильтрами по id события, id исполнителя и id автора

DELETE /tasks/{id} - удаление задачи по id (проверка по header - удалить может только автор)

Модель Task включает следующие поля: title, description, createdDateTime, deadline, status, assigneeId, authorId, eventId


Задача 4

Написать микросервис registration_service. Эндпоинты:

POST /registrations - создание регистрации (в ответ возвращается номер заявки и четырехзначный пароль доступа)

PATCH /registrations - обновление заявки (в dto приходит номер и пароль, обновление происходит, если они введены корректно. Обновить можно только username, email, phone)

GET /registrations/{id} - получение регистрации по id (не возвращается номер заявки и пароль)

GET /registrations?page={page}&size={size}&eventId={eventId} - получение списка регистраций с пагинацией и с обязательным указанием id события (не возвращается номер заявки и пароль)

DELETE /registrations - удаление регистрации (по связке номера + пароля из dto)

Модель Registration включает следующие поля: username, email, phone, eventId, номер заявки, сгенерированный пароль


Задача 5

Написать микросервис review_service. Эндпоинты:

POST /reviews - создать отзыв

PATCH /reviews/{id} - обновить отзыв (обновить может только автор (проверяем по header), нельзя обновить authorId, createdDateTime, updatedDateTime, eventId)

GET /reviews/{id} - получить отзыв по id (вернуть без authorId)

GET /reviews?page={page}&size={size}&eventId={eventId} - получить отзывы с пагинацией и обязательно по заданному id события (вернуть без authorId)

DELETE /reviews/{id} - удалить отзыв (проверка по header, что удаляет автор)

Модель Review включает следующие поля: authorId, username, title, content, createdDateTime, updatedDateTime, mark, eventId

Требования к задачам 6-10: взять задачу в том микросервисе, в котором вы ещё не работали. Написать миграции, если нужны. Обновить и дописать тесты.


Задача 6

В микросервис event_service к Event добавить команду организаторов.

Отдельный эндпоинт на добавление пользователя в команду, на вход приходят userId, eventId, role (роль - исполнитель/менеджер, можно придумать другие). Проверить, что событие с таким eventId существует.

Отдельный эндпоинт на удаление пользователя из команды или на обновление его роли.

Отдельный эндпоинт на получение всей команды указанного события.

Добавлять членов команды может владелец проекта или участник проекта с ролью менеджер.


Задача 7

В микросервис task_service добавить возможность объединять задача в группы (эпики). У каждой группы должен быть свой ответственный пользователь. Эндпоинты:

создать группу (название, ответственный, eventId, дедлайн)

обновить группу (название, ответственный, дедлайн)

добавить задачу в группу (может делать только ответственный группы, задача может быть только из проекта с eventId этой группы)

удалить задачу из группы (может делать только ответственный группы)

получить группу по id со всеми её задачами


Задача 8

В микросервис review_service добавить возможность ставить лайки и дизлайки отзывам. Автор отзыва не может оценивать свой отзыв. Если пользователь уже поставил лайк, то повторно его поставить не может. Если пользователь уже поставил лайк, а теперь ставит дизлайк, то лайк просто удаляется, а дизлайк не сохраняется, аналогично наоборот. Эндпоинты:

добавить лайк

удалить лайк

добавить дизлайк

удалить дизлайкОбновить dto таким образом, чтобы вместе с отзывов возвращались поля с количеством лайков и дизлайков


Задача 9

В микросервис review_service добавить аналитику. Нужно добавить эндпоинт(ы) (их необходимо продумать самостоятельно), который(ые) могут возвращать:среднюю оценку по мероприятию, среднюю оценку по пользователю (т.е. по всем отзывам одного пользователя), количество отзывов, процент хороших и процент плохих отзывов для одного события. И эндпоинт, возвращающий три лучших и три худших отзыва по eventId. 

При подсчете средней оценки не нужно учитывать отзывы, в которых количество дизлайков превосходит количество лайков. Это правило работает только в том случае, если общее количество лайков и дизлайков больше 10


Задача 10

В микросервис registration_service добавить возможность одобрения регистрации организаторами события. Для этого в регистрацию нужно добавить поле status, по умолчанию равное PENDING, и эндпоинт для обновления статуса заявки: отклонить (с указанием причины), одобрить, поставить в лист ожидания. Если заявка со статусом APPROVED удаляется, то заявка с самым ранним временем создания из листа ожидания переходит в PENDING. Добавить эндпоинт для получения заявки по заданным статусам (одному или более) и по eventId, отсортированными по дате создания. Добавить эндпоинт, возвращающий количество заявок в разных статусах по eventId.




Чек-лист по 1 спринту

разработано 5 микросервисов (они запускаются)

в микросервисах присутствуют эндпоинты, необходимые по задачам

в каждом микросервисе есть миграции для создания схемы базы данных

в каждом микросервисе есть юнит и интеграционные тесты (покрытие кода должно быть 60%)

все эндпоинты протестированы с помощью postman

в каждом микросервисе имеется Dockerfile и docker-compose.yaml (с двумя сервисами: само приложение и база данных)

микросервисы поднимаются и корректно работают в докере

каждая задача прошла этап ревью


Спринт 2: 21 ноября - 27 ноября


Задание 11-15

Для каждого из пяти микросервисов (user_service, event_service, task_service, registration_service, review_service):

В микросервисе настроить github ci так, чтобы при каждом создании ПР и при каждом пуше в ПР проходила сборка проекта, прогон тестов и (задача со звездочкой) чекстайл и проверка покрытия кода тестами через jacoco (60%). В настройках репозитория добавить правило, запрещающее пушить коммиты в мастер-ветку без ПРа (т.е. напрямую). Добавить один обязательный approval, чтобы ПР можно было смержить.




Задание 16-20

Для каждого из пяти микросервисов (user_service, event_service, task_service, registration_service, review_service):

Научиться разворачивать микросервис с его базой данных на сервере. Задача со звездочкой - разворачиваться должны докер контейнеры (само приложение + его база данных). Задача с двумя звездочками - сделать развертывание (деплой) через github actions (без докер контейнеров, т.е. на сервер загружаются jar файлы и там запускаются). Задача с тремя звездочками - сделать развертывание (деплой) через github actions с использованием докер-контейнеров. При использовании github actions настроить деплой при каждом пуше в master-ветку или (задача со звездочкой) - по ручному запуску.




Чек-лист по 2 спринту

в каждом из 5 микросервисов настроен github ci так, что при каждом ПРе и при каждом новом пуше в ПР происходит: сборка проекта, прогон тестов и (задачи со звездочкой) чекстайл и проверка покрытия кода тестами через jacoco.

github репозиторий для каждого из микросервисов настроен таким образом, что нельзя запушить напрямую в master-ветку (любые изменения в мастер попадают только через ПР), а для мерджа ПР необходим как минимум 1 аппрув.

каждый из 5 микросервисов развернут на сервере. К эндпоинтам этого микросервиса можно обратиться через postman, установленный на локальном компьютере, и получить успешный ответ. 

микросервисы разворачиваются на сервере либо руками, либо через github actions.


Спринт 3: 28 ноября - 4 декабря


Задача 21 - 25

Добавить сваггер в каждый из микросервисов


Задача 26

В event_service добавить проверки на существование пользователя при создании мероприятия (проверяем ownerId) и при добавлении участника в команду (проверяем всех переданных участников). Для этого сделать запрос к user_service.


Задача 27

В task_service добавить проверку на существование мероприятия, а также на то, что assigneeId, authorId и ответственный за группу задач принадлежат команде этого мероприятия. Для этого сделать запросы к user_service и event_service.


Задача 28

В registration_service добавить проверку на существование мероприятия при создании заявки и что тот, кто изменяет статус заявок, является владельцем или менеджером соответствующего события. Для этого необходимо сделать запросы к event_service.


Задача 29

В event_service добавить поле статус регистрации (открыта/закрыта/приостановлена) в Event. Также в event_service сделать возможность получить все события, на которые регистрация открыта (для этого нужно обновить уже существующий эндпоинт получения списка мероприятий), а в registration_service должна быть проверка на то, что пользователь регистрируется на мероприятие с открытой регистрацией. Для этого необходимо сделать запрос к event_service.


Задача 30

В event_service добавить ограничение на количество участников в событии (необязательное, можно обновлять), а в registration_service учитывать это следующим образом: каждый раз при подтверждении очередной заявки проверять, не нарушен ли лимит. Если лимит нарушен, то оставлять подтвержденными заявки в нужном количестве, а остальные (последние одобренные сверх лимита) отправлять в список ожидания (новый статус заявки). Для этого необходимо сделать запрос к event_service.


Задача 31

В registration_service должно быть запрещено удалять свою APPROVED заявку, если мероприятие уже началось. Для этого необходимо сделать запрос к event_service.


Задача 32

В registration_service при создании заявки на регистрацию необходимо создавать нового пользователя в user_service, а присвоенный userId сохранять в registration_service к соответствующей заявке. Если заявка удаляется, то удаляется и соответствующий пользователь. Для этого необходимо сделать запросы к user_service.


Задача 33

В review_service проверяется, что отзыв написан к уже состоявшемуся мероприятию пользователем, который принимал участие в этом мероприятии (статус его заявки approved). Для этого необходимо сделать запросы к event_service и registration_service.


Чек-лист по 3 спринту

В микросервисы добавлен сваггер (в минимальном варианте - не нужно подробно всё документировать, достаточно реализации по умолчанию)

С локального компьютера можно открыть сваггер микросервисов, расположенных на сервере

Микросервисы общаются между собой. Для этого в идеале нужно использовать FeignClient, вариант проще, но тоже ок, - WebClient. 

Если на сервере приложения были развернуты в докер-контейнерах, то также необходимо выполнить настройку сети таким образом, чтобы они видели друг друга и могли общаться. 

